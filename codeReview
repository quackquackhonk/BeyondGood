How flexible are the interfaces you were given?

Their interfaces were sufficiently flexible, although they highlighted the different design our group 
made in comparison to theirs. For example, we had a Value interface that extended our CellContents interface, as it is possible for a String, Boolean, or Double, to be the sole contents of a cell. However, 
their Value interface had no relation to their Cell class. Another example of different design choices is that their cells are autonomous and can evaluate themselves, even if they contain formulas and references. This requires passing in the values of other cells at construction, something we believed was information that an individual cell should not be privy to. Despite these differences in design, adapter classes were easy enough to design, maintaining their funcitonality as well as ours.

-------------------------------------
How capable are the views?

Their view is quite capable, and implemented infinite scrolling better than ours did. One possible 
point of improvement is stronger view model decoupling. Their view has a private field for a read-only worksheet model, which is subsequently passed down to the scrolling panel, and then their grid drawing class. The only method ever called on this model is getCell().  Although the model can't be mutated, it seems like 
unneccesary for the view to have three references to the model for one method.  Our solution passes in initial cells to the view from the controller, and only sends additional cells as they are created. This completely decouples the view from the model.  There are tradeoffs however, as our view stores the string version of the cells it needs to display, while theirs does not. The ideal design is most likely one that doesn't require the view to store the cells it needs to render, while maintaining strong view model decoupling.

--------------------------------------
How convenient was it to reuse their code?

We didn't have to change their view in any way, or ask them to change their code. Although their design 
was quite different from our own, once we figured out how they designed their MVC, the adapters were not 
too difficult to make.

--------------------------------------
How cleanly written and well-documented was their code?

The documentation for their code was concice and well written. This included methods for handling 
key events that were implemented to a certain degree. However, their view never set any keyboard handlers,
so we spent a lenghty amount of time trying to figure out how they added key event functinality. After
some time, we emailed them, and stated they never handled keyboard events.  They should have commented 
that these methods would be implemented in the future, or were never used, as we spent much too long
trying to figure something out that they never even did.

-------------------------------------------
If you needed to request changes from them, what were they and why were they needed?

Their code didn't require any changes, though we emailed them questions. They were responsive and helpful.

-------------------------------------------
Summary

Their code was well written and was well implemented for the design that they came up with. Our design was different, but once we figured out their design, designing adpater classes was not too difficult. Their documentation was good, save for failing to note that they did not implement their key event methods.